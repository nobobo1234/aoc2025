import { readFileSync } from 'fs';

const input = readFileSync('input.txt')
    .toString()
    .trim()
    .split("\n")
    .map(coordStr => coordStr.split(',').map(Number))

const part1 = (input) => {
    let maxSize = 0;
    for (const [x1, y1] of input) {
        for (const [x2, y2] of input) {
            const size = (1 + Math.abs(x1 - x2)) * (1 + Math.abs(y1 - y2));
            if (size > maxSize) {
                maxSize = size;
            }
        }
    }

    return maxSize;
}

const toNum = (x, y, width) => y * width + x

const isValid = (grid, [x1, y1], [x2, y2]) => {
    let valid = true;

    loop:
    for (let cx = x1; cx <= x2; cx++) {
        for (let cy = y1; cy <= y2; cy++) {
            valid = false; 
        }
    }
}

const part2 = (input) => {
    // Honeslty I couldn't get this one, tried 20 different things but found
    // coordinate compression from this video from @HyperNeutrino and worked
    // from that idea.
    // https://www.youtube.com/watch?v=toDrFDh7VNs
    const xs = Array.from(new Set([...input].map(([x, _]) => x))).sort((a, b) => a - b)
    const ys = Array.from(new Set([...input].map(([_, y]) => y))).sort((a, b) => a - b)
    const [width, height] = [xs.length, ys.length]

    const grid = Array.from({ length: height })
        .map(_ => Array.from({ length: width }).fill(false))

    for (let i = 0; i < input.length; i++) {
        const [x1, y1] = input[i]
        let nextI = i + 1;
        if (i === input.length - 1) {
            nextI = 0;
        }
        let [x2, y2] = input[nextI]

        let [cx1, cx2] = [xs.indexOf(x1), xs.indexOf(x2)].sort((a, b) => a - b); 
        let [cy1, cy2] = [ys.indexOf(y1), ys.indexOf(y2)].sort((a, b) => a - b);

        for (let fx = cx1; fx <= cx2; fx++) {
            for (let fy = cy1; fy <= cy2; fy++) {
                grid[fy][fx] = true;
            }
        }
    }
    
    // Perform floodfill
    const outside = new Set([toNum(-1, -1, width)])
    const stack = [[-1, -1]]

    while (stack.length !== 0) {
        let [cx, cy] = stack.pop();

        for (let [nx, ny] of [[cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]]) {
            if (nx < -1 || ny < -1 || nx > width || ny > height) continue;
            if (nx >= 0 && nx < width && ny >= 0 && ny < height && grid[ny][nx]) continue;
            if (outside.has(toNum(nx, ny, width))) continue;
            outside.add(toNum(nx, ny, width))
            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                grid[ny][nx] = false
            };
            stack.push([nx, ny]);
        }
    }
    
    for (let cx = 0; cx < width; cx++) {
        for (let cy = 0; cy < width; cy++) {
            let asNum = toNum(cx, cy, width)

            if (!outside.has(asNum)) grid[cy][cx] = true
        }
    }

    for (let [x1, y1] of input) {
        for (let [x2, y2] of input) {
            let [cx1, cx2] = [xs.indexOf(x1), xs.indexOf(x2)].sort((a, b) => a - b); 
            let [cy1, cy2] = [ys.indexOf(y1), ys.indexOf(y2)].sort((a, b) => a - b);

            
        }
    }
}


const exInput = `
7,1
11,1
11,7
9,7
9,5
2,5
2,3
7,3
`
    .toString()
    .trim()
    .split("\n")
    .map(coordStr => coordStr.split(',').map(Number))

console.log("Example part 1: ", part1(exInput))
console.log("Part 1: ", part1(input))

console.log("Example part 2: ", part2(exInput))
console.log("Part 2: ", part2(input))
